name: Render Manifests on Values Change

on:
  push:
    branches:
      - main
    paths:
      - 'dev/**/*.yaml'
      - 'prod/**/*.yaml'

permissions:
  contents: write  # Required to push to rendered-manifests repo
  id-token: write  # Required for Workload Identity Federation (GCP auth)
  
env:
  HELM_TEMPLATES_VERSION: v1.3.2  # Updated for GCPBackendPolicy support (Gateway API + IAP)

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.detect.outputs.services }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed services
        id: detect
        run: |
          echo "ðŸ” Detecting which service values changed..."
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
          
          # Extract service names and environments
          SERVICES=$(echo "$CHANGED_FILES" | grep -E '(dev|prod)/[^/]+/values\.yaml' | \
            awk -F'/' '{print $1 ":" $2}' | sort -u | jq -R -s -c 'split("\n")[:-1]')
          
          echo "Changed services: $SERVICES"
          echo "services=$SERVICES" >> $GITHUB_OUTPUT

  render-and-deploy:
    name: Render ${{ matrix.service }}
    needs: detect-changes
    if: needs.detect-changes.outputs.services != '[]'
    runs-on: ubuntu-latest
    environment: dev  # Use dev environment for accessing GCP credentials
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
    steps:
      - name: Parse environment and service
        id: parse
        run: |
          ENV=$(echo "${{ matrix.service }}" | cut -d: -f1)
          SERVICE=$(echo "${{ matrix.service }}" | cut -d: -f2)
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "service=$SERVICE" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Rendering: $SERVICE in $ENV environment"

      - name: Checkout helm-values
        uses: actions/checkout@v4
        with:
          path: helm-values

      - name: Checkout helm-templates
        uses: actions/checkout@v4
        with:
          repository: ritual-app/helm-templates
          ref: ${{ env.HELM_TEMPLATES_VERSION }}
          path: helm-templates
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout rendered-manifests
        uses: actions/checkout@v4
        with:
          repository: ritual-app/rendered-manifests
          ref: main
          path: rendered-manifests
          token: ${{ secrets.SHARED_DISPATCH_TOKEN }}

      - name: Get current image tag
        id: get-image
        env:
          ENVIRONMENT: ${{ steps.parse.outputs.environment }}
          SERVICE: ${{ steps.parse.outputs.service }}
        run: |
          echo "ðŸ” Getting current image tag from rendered-manifests..."
          
          DEPLOYMENT_FILE="rendered-manifests/${ENVIRONMENT}/${SERVICE}/deployment.yaml"
          
          if [ -f "$DEPLOYMENT_FILE" ]; then
            # Extract current image tag from deployment (strip quotes)
            CURRENT_IMAGE=$(grep -A 5 "image:" "$DEPLOYMENT_FILE" | grep "image:" | awk '{print $2}' | head -1 | tr -d '"')
            IMAGE_TAG=$(echo "$CURRENT_IMAGE" | cut -d: -f2)
            IMAGE_REPO=$(echo "$CURRENT_IMAGE" | cut -d: -f1)
            
            echo "Current image: $CURRENT_IMAGE"
            echo "Repository: $IMAGE_REPO"
            echo "Tag: $IMAGE_TAG"
            
            echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
            echo "image_repo=$IMAGE_REPO" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  No existing deployment found. Using 'main-latest' as default."
            
            # Determine registry based on environment
            if [ "$ENVIRONMENT" = "dev" ]; then
              PROJECT="ritual-app-dev-104fc"
            else
              PROJECT="ritual-app-aa489"
            fi
            
            IMAGE_REPO="us-east1-docker.pkg.dev/${PROJECT}/docker/${SERVICE}"
            IMAGE_TAG="main-latest"
            
            echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
            echo "image_repo=$IMAGE_REPO" >> $GITHUB_OUTPUT
          fi

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Fetch parameters from GCP Parameter Manager
        id: fetch-params
        env:
          ENVIRONMENT: ${{ steps.parse.outputs.environment }}
          SERVICE: ${{ steps.parse.outputs.service }}
        run: |
          echo "ðŸ“‹ Fetching parameters from GCP Parameter Manager..."
          
          # Determine project ID based on environment
          if [ "$ENVIRONMENT" = "dev" ]; then
            PROJECT_ID="ritual-app-dev-104fc"
          else
            PROJECT_ID="ritual-app-aa489"
          fi
          
          echo "  Project: ${PROJECT_ID}"
          echo "  Environment: ${ENVIRONMENT}"
          echo "  Service: ${SERVICE}"
          
          # Function to fetch and flatten a parameter
          fetch_params() {
            local PARAM=$1
            local OUTFILE=$2
            local VER="latest"
            
            echo "  Fetching parameter: ${PARAM}"
            
            # Check if parameter exists
            if ! gcloud parametermanager parameters describe "${PARAM}" \
              --project="${PROJECT_ID}" \
              --location=global &>/dev/null; then
              echo "  âš ï¸  Parameter ${PARAM} not found, skipping..."
              return
            fi
            
            # Fetch and decode
            local RAW=$(gcloud parametermanager parameters versions describe "${VER}" \
              --parameter="${PARAM}" \
              --project="${PROJECT_ID}" \
              --location=global \
              --format="value(payload.data)")
            
            # Decode and flatten JSON to env format
            echo "$RAW" | base64 --decode \
              | jq -r '
                  . as $in
                  | paths(scalars) as $p
                  | select($p|length > 1)
                  | ($p[1:] | map(tostring) | join("_"))
                    + "="
                    + ($in|getpath($p) | tostring)
                ' >> "$OUTFILE"
          }
          
          # Create params file
          > params.env
          
          # Fetch common parameters (shared across all services)
          echo "ðŸ“‹ Fetching common-params..."
          fetch_params "common-params" params.env || true
          
          # Fetch service-specific parameters
          echo "ðŸ“‹ Fetching ${SERVICE} params..."
          fetch_params "${SERVICE}" params.env || true
          
          # Convert to YAML format for Helm
          echo "ðŸ”„ Converting to YAML format..."
          > params.yaml
          echo "# Auto-generated parameters from GCP Parameter Manager" >> params.yaml
          echo "parametersFromGCP:" >> params.yaml
          
          while IFS='=' read -r key value; do
            [[ -z "$key" ]] && continue
            # Escape special YAML characters in value
            value_escaped=$(echo "$value" | sed 's/"/\\"/g')
            echo "  ${key}: \"${value_escaped}\"" >> params.yaml
          done < params.env
          
          if [ -s params.env ]; then
            echo ""
            echo "âœ… Parameters fetched and converted to YAML:"
            cat params.yaml
          else
            echo "âš ï¸  No parameters found, using empty params file"
          fi
          
          echo ""
          echo "params_file=$(pwd)/params.yaml" >> $GITHUB_OUTPUT

      - name: Render Helm chart with new values
        env:
          ENVIRONMENT: ${{ steps.parse.outputs.environment }}
          SERVICE: ${{ steps.parse.outputs.service }}
          IMAGE_TAG: ${{ steps.get-image.outputs.image_tag }}
          IMAGE_REPO: ${{ steps.get-image.outputs.image_repo }}
          PARAMS_FILE: ${{ steps.fetch-params.outputs.params_file }}
        run: |
          echo "ðŸŽ¨ Rendering Helm chart..."
          echo "  Environment: ${ENVIRONMENT}"
          echo "  Service: ${SERVICE}"
          echo "  Image: ${IMAGE_REPO}:${IMAGE_TAG}"
          echo "  Parameters: ${PARAMS_FILE}"
          
          # Sanitize service name for Helm (replace underscore with dash)
          HELM_RELEASE_NAME=$(echo "${SERVICE}" | tr '_' '-')
          echo "  Helm Release: ${HELM_RELEASE_NAME}"
          
          # Build helm command with parameters if file exists
          if [ -f "${PARAMS_FILE}" ] && [ -s "${PARAMS_FILE}" ]; then
            echo "  âœ“ Using parameters from GCP Parameter Manager"
            helm template ${HELM_RELEASE_NAME} \
              helm-templates/${ENVIRONMENT} \
              --values helm-values/${ENVIRONMENT}/${SERVICE}/values.yaml \
              --values ${PARAMS_FILE} \
              --set image.tag=${IMAGE_TAG} \
              --set image.repository=${IMAGE_REPO} \
              --namespace ${ENVIRONMENT} \
              --output-dir ./rendered
          else
            echo "  âš ï¸ No parameters file, using only values.yaml"
            helm template ${HELM_RELEASE_NAME} \
              helm-templates/${ENVIRONMENT} \
              --values helm-values/${ENVIRONMENT}/${SERVICE}/values.yaml \
              --set image.tag=${IMAGE_TAG} \
              --set image.repository=${IMAGE_REPO} \
              --namespace ${ENVIRONMENT} \
              --output-dir ./rendered
          fi
          
          echo "âœ… Rendered manifests:"
          find ./rendered -type f -name "*.yaml" -exec echo "  - {}" \;

      - name: Push rendered manifests
        env:
          ENVIRONMENT: ${{ steps.parse.outputs.environment }}
          SERVICE: ${{ steps.parse.outputs.service }}
          IMAGE_TAG: ${{ steps.get-image.outputs.image_tag }}
          RENDERED_REPO_TOKEN: ${{ secrets.SHARED_DISPATCH_TOKEN }}
          HELM_TEMPLATES_VERSION: ${{ env.HELM_TEMPLATES_VERSION }}
        run: |
          echo "ðŸ“¦ Pushing rendered manifests..."
          
          cd rendered-manifests
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Clear old manifests
          rm -rf ${ENVIRONMENT}/${SERVICE}
          mkdir -p ${ENVIRONMENT}/${SERVICE}
          
          # Copy new manifests
          cp -r ../rendered/${ENVIRONMENT}/templates/* ${ENVIRONMENT}/${SERVICE}/ 2>/dev/null || \
          cp -r ../rendered/microservice/templates/* ${ENVIRONMENT}/${SERVICE}/ || true
          
          # Add metadata to each file
          for file in ${ENVIRONMENT}/${SERVICE}/*.yaml; do
            if [[ -f "$file" ]]; then
              {
                echo "# ðŸ¤– AUTO-GENERATED - DO NOT EDIT MANUALLY"
                echo "# Generated by: GitHub Actions (helm-values repository)"
                echo "# Service: ${SERVICE}"
                echo "# Environment: ${ENVIRONMENT}"
                echo "# Image Version: ${IMAGE_TAG} (unchanged - values only update)"
                echo "# Helm Templates: ${HELM_TEMPLATES_VERSION}"
                echo "# Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
                echo "# Commit SHA: ${{ github.sha }}"
                echo "# Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                echo "# Reason: Values change in helm-values repository"
                echo "---"
                cat "$file"
              } > temp
              mv temp "$file"
            fi
          done
          
          # Commit and push
          git add ${ENVIRONMENT}/${SERVICE}/
          
          if git diff --staged --quiet; then
            echo "âš ï¸  No changes to commit"
          else
            git commit -m "ðŸ”§ Update ${SERVICE} ${ENVIRONMENT} config (values only)

          Updated by: helm-values workflow
          Image tag: ${IMAGE_TAG} (unchanged)
          Values commit: ${{ github.sha }}
          
          This is a configuration-only update (no Docker build)"
            
            # Pull and push with retry logic (handles parallel workflow runs)
            MAX_RETRIES=5
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              echo "ðŸ”„ Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES: Pulling latest changes..."
              git pull --rebase origin main
              
              echo "ðŸ“¤ Pushing changes..."
              if git push; then
                echo "âœ… Manifests pushed successfully!"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  WAIT_TIME=$((RETRY_COUNT * 3))
                  echo "âš ï¸  Push failed, retrying in ${WAIT_TIME}s..."
                  sleep $WAIT_TIME
                else
                  echo "âŒ Failed to push after $MAX_RETRIES attempts"
                  exit 1
                fi
              fi
            done
          fi

      - name: Summary
        env:
          ENVIRONMENT: ${{ steps.parse.outputs.environment }}
          SERVICE: ${{ steps.parse.outputs.service }}
          IMAGE_TAG: ${{ steps.get-image.outputs.image_tag }}
        run: |
          echo "## âœ… Config Update Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** \`${SERVICE}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${ENVIRONMENT}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${IMAGE_TAG}\` (unchanged)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**â±ï¸ No Docker build required - config-only update!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ArgoCD will auto-sync the changes within 3 minutes." >> $GITHUB_STEP_SUMMARY

